열심히 키보드로 쳐보면서 연습하기.


## 화살표 함수
화살표함수는 선언문이 없고 표현식에. 매개변수가 하나면 생략 가능하지만 두개 이상이면 생략 불가.


# 26. 배열
## 1. 배열이란?
자료구조는 데이터들을 어떤식으로 구조화할까. 가장 쉬운게 배열. 자료구조를 배워야 하는 이유. 여러개의 값을 하나의 그룹으로 관리하는 것이 자료구조. 객체는 값을 찾아가는게 빠름. 고유한 이름(키)가 붙어있기 때문에. 배열은 키가 없고 순서가 있음.
배열은 요소들의 순서가 키와 마찬가지. 객체는 순서에 의미가 없음. 배열의 순서를 인덱스라고 함. 자바스크립트의 배열은 엄격히 말해서 배열이 아닌 객체.
왜 객체로 배열을 만들었을까. 다른 언어들의 배열보다 나음.
배열도 리터럴로 만들 수 있음. Array라는 생성자함수로도 만들 수 있음. 모든 배열의 프로토타입은 array.prototype
array.prototype 의 프로토타입은 object.prototype.
배열은 객체이기 때문에 typeof 하면 object.
배열, 함수 모두 객체. 배열과 함수의 상위 개념은 객체. 객체도 하위 개념이 있다고 가정한다면 객체라는 타입을 우리가 조금 더 상세하게 쪼갠다면 string, number, 정규표현식 등등의 배열이 있음. Echa 스크립트에 써있는 것은 아니고 편의상.

모든 배열은 요소를 갖는다. 요소로 쓸 수 있는 값은 자바스크립트에서 값으로 쓸 수 있는 모든 것. 자바스크립트의 배열은 객체이므로 객체의 프로퍼티 값은 모든 값이 올 수 있음. 베열은 for문으로 돌리기 좋음. 차례차례 접근 가능. 자바스크립트는 한 배열 내에서 다양한 타입의 값이 올 수 있지만 다른 언어들은 한 타입만 올 수 있음.

접근할 때는 인덱스로 접근. 대괄호표기법. 배열은 반드시 length 프로퍼티를 갖고 있음. argument 객체도 length 갖고 있음. argument는 프로퍼티 키가 0,1,2...로 생김. 유사배열 객체. length 값은 마지막 인덱스 +1

배열은 객체이지만 일바 객체와는 다른 특징이 있음

```
| 구분            | 객체                      | 배열          |
|-----------------|---------------------------|---------------|
| 구조            | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
| 값의 참조       | 프로퍼티 키               | 인덱스        |
| 값의 순서       | x                         | ○             |
| length 프로퍼티 | x                         | ○             |
```

# 2. 자바스크립트의 배열은 배열이 아니다.
밀집 배열: 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접. 중간에 메모리가 이어져있음. 요소들이 여러 개 있을 때 임의접근(랜덤 어세스)를 빠르게 할 수 있음.
단점은 데이터를 추가하거나 삭제할 때.
일반적인 의미의 자료구조의 배열은 요소에 접근할 때 강점을 가지고 있음. 요소를 추가하는 일이 있을 때도.
해시테이블은 해시 함수를 써서 메모리의 위치를 정함. 자바스크립트 배열은 객체의 포로퍼티 값을 요소로 갖고 있기 때문.
해시테이블은 데이터를 추가하거나 삭제하는 것은 빠르지만 임의 접근이 느림. 배열과 반대.
임의 접근하는 속도는 일반적인 배열보다 느릴 수 있으나 최적화했기 때문에 그다지 느리지 않음.
입사질문- 자바스크립트의 배열이 일반 배열인가? 자바스크립트의 배열은 일반적인 배열의 개념과는 다르다. 순수한 객체로 구현되어져있지만 임의 접근, 즉 요소에 접근할 때 속도가 느릴 수 밖에 없는 구조적 단점을 해결하기 위해 그 속도가 일반적으로 접근하는 것보다 2배 이상 빠름. 데이터를 삭제하는 것은 고속으로 돌기 때문에 성능상 일반적인 배열보다 느리지 않다.
희소배열 만들지 말고 테이터타입을 통일해서 만드는 것이 좋음. length 프로퍼티 조작하지 않기, 빈 공간 만들지 않기.


## 배열 생성
### 4.1 배열 리터럴
배열을 만들때는 요소가 무엇인지 알고 있다는 가정이 있어야 함.

### 4.2 Array 생성자 함수
전달된 인수의 개수에 따라 다르게 동작

## 5. 배열 요소의 참조
대괄호 표기법 사용.
존재하지 않는 요소에 접근하면 undefined.

## 6. 배열 요소의 추가와 갱신

## 7. 배열 요소의 삭제
delete 연산자는 쓰지 않기. 퍼포먼스에 악영향을 주고 length 프로퍼티에 반영이 안됨.
희소 배열이 됨. 메소드를 써서 지우기.

## 8. 배열 메소드
배열은 객체이므로 원본을 수정할 수 있다. 배열 메소드는 결과물을 반환하는 패턴이 2가지. 배열에는 원본 배열을 직접 변경하는 메소드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드가 있음
일관성있게 accessor 메소드로 코딩하는게 좋음.

### 8.3 Array.prototype.pop
pop메소드와 push 메소드를 사용하면 스택을 쉽게 구현할 수 있다.

스프레드 문법으로 push처럼 추가 가능(배열이 새롭게 만들어짐)

### 8.8 slice
slice는 복사할 때 많이 씀.

```
const arr = [1, 2, 3];

// 인수를 생략하면 원본 배열의 복사본을 생성하여 반환한다.
const copy = arr.slice();
console.log(copy); // [1, 2, 3]
console.log(copy === arr); // false

```
얕은 복사와 깊은 복사
얕은 복사는 1단계만 복사. 똑같은 객체를 봄.
깊은 복사는 안에 있는 것까지 모두 복사.
얕은 복사는 복사가 되지 않은 것이나 마찬가지. 깊은 복사는 재귀로. 실무에서 딥카피를 쓸 때는 내가 만들지 말고 라이브러리 써야 함.(lodash의 deepclone)


### 8.9 indexOf

```
const arr = [1, 2, 2, 3];

// 배열 arr에서 요소 2를 검색하여 첫번째 인덱스를 반환
arr.indexOf(2);    // -> 1
// 배열 arr에서 요소 4가 없으므로 -1을 반환
arr.indexOf(4);    // -1
// 두번째 인수는 검색을 시작할 인덱스이다. 두번째 인수를 생략하면 처음부터 검색한다.
arr.indexOf(2, 2); // 2
```
배열에 요소가 존재하는지 확인할 때 유용

### 8.10 join
join 메소드는 원본 배열의 모든 요소를 문자열로 벼환한 후 인수로 전달받은 값, 즉 구분자로 연결된 문자열을 반환. 구분자는 생략 가능하면 기본 구분자는 ; 이다.

## 9. 배열 고차 함수
### 9.1 sort
유니코드의 순서대로 비교. 숫자는 제대로 비고 안됨.

### 9.3 forEach
for문의 대용
continue, break 못함. 한번 돌기 시작하면 끝까지 다 돌게됨. 중간에 못빠져나감.
굳이 쓸 이유는 별로 없음
Accessor. this  값을 임의로 고치고 싶을 때 고칠 수 있는 능력이 있음(콜백은 고칠 수 있음) this를 직접 고치면 됨. for Each 메소드가 존재하지 않으면 폴리필을 추가
두번째 옵션은 줄 수도 있고 안줄 수도 있음. 호출할 때 인수를 전달하지 않으면 undefined. 단축평가는 falsy.
for each는 가독성이 좋음. 일반적으로는 for each 쓰고 성능이 중요하다면 for문 쓰기(알고리즘 문제에는 for문)