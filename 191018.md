## 8. 캡슐화
프로퍼티 중에 공개할 것과 공개하지 않을 것을 구별. 정보은폐와 일맥상통. 중첩함수는 외부에서 호출할 수 없음. 중첩함수도 외부에서 호출할 수 없기 때문에 캡슐화 된 것. 외부에서 노출시키려고 하면 모듈 패턴 사용. 객체 자체를 리턴하기. 자바스크립트가 접근제한자를 갖지 않는 이유는 필요가 없기 때문.

함수내에 있는 변수의 생명주기는 함수가 끝나는 동시에 끝난다. foo라는 함수 내부에서 변수를 선언. foo를 밑에서 호출. foo라는 함수 안에서 선언한 x변수는 함수 호출이 되고 함수의 실행이 끝나면 죽음.(더이상 필요 없어서 생애주기를 종료) 그래서 지역변수를
써야함. 라이프 사이클이 짧기 때문에. var 키워드로 전역 변수가 끝나면 오래감. let, const로 선언한 변수는 var 선언한 변수보다 오래 걸림.
객체가 언제 태어나서 언제 죽는지 알고 있어야함. 죽는다는 것은 더이상 참조할 수 없다는 것. Person.prototype.sayHi는 프로퍼티로 추가한 것.메서드. 중첩함수가 아님. 메서드는 객체가 살아있으면 언제든지 호출 가능.
모든 함수는 자신이 생성될 때 자신의 상위 스코프를 기억한다. (렉시컬 Environment
). 모든 함수가 가지고 있는 내부슬롯 \[[environment]] 안죽기 때문에 살아있는 것.
일반함수는 자신이 태어날 때 prototype도 만듦. 중복되지 않게 올려놓고 써야함. 아예 일반 함수로 만들지 않는 것.
가장 심플한 방식은 화살표함수를 쓰는 것. 프로토타입을 안보기 때문에.
클로저를 통해 정보은폐를 할 수 있음.
Object.create

함수도 메서드를 가질 수 있다. Object.create
프로토타입 메소드, 인스턴스 메소드, 정적 메소드 구분할 수 있어야 함.

## 14. 프로퍼티 존재 확인
Person이라는 객체의 정의를 볼 수 없는 경우 person에 name이 있는지 확인해보려고 할 때 in 사용. 상속 관계에 있는 모든 프로퍼티를 다 봄. toStrigin 이라는 메소드는 Object.prototype 에 있음.. true가 나오는 것은 상속 가능한 것들까지 모두 true로 봄.
상속은 됐고 내가 가지고 있는 것만 보고싶을 때는 hasOwnProterty.
this는 반드시 객체를 가리킴.
일반함수 내에서는 this를 쓸 일이 없음.

# 20.전역객체
전역객체는 반드시 자바스크립트 엔진이 만듦. 브라우저가 가동되자 마자 만든다. 표준 빌트인 객체를 가지고 있음.
환경에 따라 전역객체의 이름이 다름. 전역객체는 개발자가 의도적으로 생성할 수 없으며 전역객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 전역 렉시컬 환경의 선언적...

# 21. this
함수를 정의하는 방식과 호출하는 방식은 일치하지 않음. this 는 함수 정의방식으로 결정하는 것이 아니라 함수를 어떻게 호출했느냐에 따라 this를 동적으로 결정.
일반함수로 호출하면 this는 항상 전역객체를 가리킴. 일반함수의 개념으로 보면 callback 함수는 고차함수 마음. 특별한 의지가 없다면 일반함수로 호출됨. 중첩함수도 외부함수 마음. 보통 일반함수로 호출되는 경우가 많음. 콜백함수, 중첩함수 내의 this는 주로 전역객체를 갖음.

생성자 함수로 생성된 this는 생성자 함수가 생성할 instance를 가리킴.
메소드로 호출한 this는 메소드를 호출한 객체를 가리킴. 주의할 점은 메소드가 어디에 소속되어있는지는 관계 없음. 콜은 별도.
this 바인딩은 함수 호출 방식에 의해 동적으로 결정. this 안쓸거면 정적 메소드 씀. 인스턴스, 프로토타입 메소드는 반드시 this가 있어야 함.

### 2.1 일반함수 호출
기본적으로 this에는 전역객체가 바인딩
중첩함수 안에서 일반 함수로 호출하면 전역객체. window.
바인드는 식별자와 값을 묶음. this에 100을 바인딩

### 2.4 Function.prototype.apply/call/bind메소드에 의한 간접 호출
우리가 가지고 있는 상태 데이터를 어떻게 가지고 있느냐에 따라 call, apply 결정. 배열로 가지고 있다면 apply 가 좋고 아니면 call이 나음.
