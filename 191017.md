# 18. 프로토타입
프로토타입을 이해하려면 상속을 알아야 함. 상속의 상위 개념은 객체지향.
자바스크립트는 대부분이 객체. 자바스크립트 엔진은 대부분 C++로 짜여있음. 자바스크립트는 웹페이지의 한정적인 용도를 위해 태어남. 사람들이 추가적인 기능을 원하자 다양한 기능 추가됨. 크롬을 만들 때 구글은 속도 신경씀. 현존하는 언어 중 빠른 것 C++.
자바스크립트는 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.
프로토타입 기반은 상속이라는 매커니즘에 기반을 둔 것. 자바스크립트에는 클래스라는 개념이 없었으나 ES6에서 생김. 내부적으로는 함수 취급을 당함.
자바스크립트를 이루는 거의 모든 것이 객체.

## 1. 객체지향 프로그래밍
객체는 눈에 보이거나 판단할 수 있는 모든 대상들을 객체라는 형태로 만듦. 속성으로 이해. 사람을 이해할 때도 속성으로 이해함. 속성의 나열로 객체를 만듦. 사람이라는 객체를 만들 때 내가 관심이 있는 속성을 추려서 하나의 객체를 만듦. 사람도 여러 명이 있음. 나도 있지만 다른 사람도 있음. 이름, 나이 등의 속성은 모두 가지고 있지만 값은 모두 다름. 속성 키, 속성 값으로 구별. 사람은 행위도 함. 행위도 포함시킴. 말하는 것(목적어)를 앞에 두기. 행위는 나의 상태와 관련 있음. 행위를 표현하는 것이 프로퍼티. 메소드는 상태와 관련 있음. 객체들은 모두 독립적. 하지만 서로 떨어져 있는 것이 아니라 관계를 맺음. 실제적인 인슽턴스를 찍어내는 방법이 생성자 함수인지, 클래스인지. 인스턴스가 태어나면 부모가 있음. 부모가 프로토타입. 태어났을 때 생성자함수에 의해 결정되어있음.
사람을 찍어내는 틀로 person 이라는 함수를 만듦. 찍어내는 것을 new, 결과물이 인스턴스.
상태는 다르지만 구조는 같음.
객체 지향의 전반적인 내용은 우리가 인식하는 대부분을 표현하는 것.
상속 관계는 어떻게 맺어지는가. 매커니즘이 프로토타입.
추상화: 다양한 속성 중에서 프로그램에 필요한 속성을 간추려 내어 표현하는 것.
원이라는 객체를 만들 때 세개의 동작은 radius에 의존함.
함수형은 외부 상태를 바꾸지 않으려고 하지만 객체지향은 바꾸려고 함. 객체지향은 radius의 변화를 감지하기 어려움.
프로퍼티는 상태를 나타내고 메소드는 동작을 나타냄. 상태와 동작은 서로 관련이 있음

## 2. 상속과 프로토타입
자식들이 똑같은 100개를 갖는 것 보다
아버지가 하나를 갖고 자식들은 상속을 받는 것이 더 효율적. 프로토타입이라는 프로퍼티는 constructor만 가지고 있음.
circle 생성자 함수는 함수 객체가 평가될 때 circle.prototype 호출. Cirle.prototype
circlee1 생성한 this. 생성자 함수가 생성할 싱스턴스를 가리킴.
프로퍼티를 찾는 매커니즘. 프로토타입 체인
프로토타입 체인은 상속관계에서 프로퍼티를 탐색하는 매커니즘. 인스턴스의 프로퍼티를 탐색하는 매커니즘.

인스턴스가 있다는 것은 new를 했다는 것. 인스턴스 메소드, 프로토타입 메소드. 정적 메소드 구분. 인스턴스 메소드는 호출하려면 반드시 인스턴스 메소드가 있어야함. 정적메소드는 인스턴스 호출 과정이 없어도 호출할 수 있음.

### 3.1 \__proto__ 접근자 프로퍼티
모든 객체는 \__proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 \[[Prototype]] 내부 슬롯에 접근 가능. 인스턴스의 프로토타입 객체 참조. 비표준이었음. ES6올라갈 때 표준화함. 현재는 표준
Object.getprototypeof
객체리터롤로 정의한
객체는 크리에이티브 오브젝트 많듦.
모든 객체는 Obbject Create에서 만듦.
객체 리터럴은 Object 생성자 함수가 생성한 것으로 볼 수 있다.(사실은 아니지만 알필요는 없음)
우리가 임의로 상속 관계를 조작하면 인스턴스가 생성자 함수를 찾아가지 못한다.
모든 객체는 프로토타입을 가지고 있다. 프로토타입의 프로토타입은 object.prototype. 일반객체의 프로토타입과 같음 object.prototype의 프로토타입은 null. 종점.
체인을 만들 때는 한없이 올라갈 때 있음.

프로토타입의 가장 위, 중간, 아래 구분하는 이유. 모든 프로토타입의 조상은 object.prototype
Object.getProtptypeOf 은 \__proto__를 참조하는 것과 같은 기능. \__proto__는 되도록 안쓰는게 좋음.

### 3.2 함수 객체의 prototype 프로퍼티
일반객체는 prototype 없음.

## 5. 프로토타입의 생성 시점
생성자함수가 생성되는 시점에.

## 5.2 빌트인 생성자 함수와 프로토타입 생성 시점
생성자함수도 함수표현식으로 만들 수 있음. 함수 선언문으로 정의했으면 런타임 이전, 표현식으로 만들면 런타임에(우리가 만든 생성자함수). 빌트인 생성자 함수는 전역 객체 소속. 전역객체가 생길 때 빌트인 생성자 함수 생김. 브라우저 켜면 생김. 전역객체가 만들어질 때 프로토타입들도 만들어짐.
Object.prototype들은 굉장하 범용서을 갖음.

상속관계를 조정하고싶으면 Object.creative 사용.

## 12. 직접상속
### 12.1 Object.create에 의한 직접 상속
자신의 프로토타입이 값이 null이라는 것은 아무것도 상속받지 않겠다는 것. 